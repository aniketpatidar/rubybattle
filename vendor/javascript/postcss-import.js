import*as e from"path";import t from"buffer";import{_ as r,a as n}from"./_/HaonENAO.js";import*as o from"postcss-value-parser";import*as s from"sugarss";import a from"./lib/resolve-id.js";import i from"process";import"read-cache";import"resolve";var p={};p=function formatImportPrelude(e,t,r){const n=[];if(typeof e!=="undefined"){let t="layer";e&&(t=`layer(${e})`);n.push(t)}typeof r!=="undefined"&&n.push(`supports(${r})`);typeof t!=="undefined"&&n.push(t);return n.join(" ")};var u=p;var c={};var l=t.Buffer;const d=u;c=function base64EncodedConditionalImport(e,t){t.reverse();const r=t.pop();let n=`${e} ${d(r.layer,r.media,r.supports)}`;for(const e of t)n=`'data:text/css;base64,${l.from(`@import ${n}`).toString("base64")}' ${d(e.layer,e.media,e.supports)}`;return n};var f=c;var m={};const h=f;m=function applyConditions(e,t){e.forEach((e=>{if(e.type==="charset"||e.type==="warning"||!e.conditions?.length)return;if(e.type==="import"){e.node.params=h(e.fullUri,e.conditions);return}const{nodes:r}=e;const{parent:n}=r[0];const o=[];for(const r of e.conditions){if(typeof r.media!=="undefined"){const e=t({name:"media",params:r.media,source:n.source});o.push(e)}if(typeof r.supports!=="undefined"){const e=t({name:"supports",params:`(${r.supports})`,source:n.source});o.push(e)}if(typeof r.layer!=="undefined"){const e=t({name:"layer",params:r.layer,source:n.source});o.push(e)}}const s=o.shift();const a=o.reduce(((e,t)=>{e.append(t);return t}),s);n.insertBefore(r[0],s);r.forEach((e=>{e.parent=void 0}));r[0].raws.before=r[0].raws.before||"\n";a.append(r);e.type="nodes";e.nodes=[s];delete e.node}))};var y=m;var v={};v=function applyRaws(e){e.forEach(((e,t)=>{if(t!==0)if(e.parent){const{before:t}=e.parent.node.raws;e.type==="nodes"?e.nodes[0].raws.before=t:e.node.raws.before=t}else e.type==="nodes"&&(e.nodes[0].raws.before=e.nodes[0].raws.before||"\n")}))};var w=v;var g={};g=function applyStyles(e,t){t.nodes=[];e.forEach((e=>{if(["charset","import"].includes(e.type)){e.node.parent=void 0;t.append(e.node)}else e.type==="nodes"&&e.nodes.forEach((e=>{e.parent=void 0;t.append(e)}))}))};var $=g;var b=o;try{"default"in o&&(b=o.default)}catch(e){}var I={};const S=b;const{stringify:C}=S;I=function parseStatements(e,t,r,n){const o=[];let s=[];t.each((t=>{let a;t.type==="atrule"&&(t.name==="import"?a=parseImport(e,t,r,n):t.name==="charset"&&(a=parseCharset(e,t,r,n)));if(a){if(s.length){o.push({type:"nodes",nodes:s,conditions:[...r],from:n});s=[]}o.push(a)}else s.push(t)}));s.length&&o.push({type:"nodes",nodes:s,conditions:[...r],from:n});return o};function parseCharset(e,t,r,n){return t.prev()?e.warn("@charset must precede all other statements",{node:t}):{type:"charset",node:t,conditions:[...r],from:n}}function parseImport(e,t,r,n){let o=t.prev();if(o)do{if(o.type!=="comment"&&(o.type!=="atrule"||o.name!=="import"))break;o=o.prev()}while(o);if(o)do{if(o.type!=="comment"&&(o.type!=="atrule"||o.name!=="charset"&&(o.name!=="layer"||o.nodes)))return e.warn("@import must precede all other statements (besides @charset or empty @layer)",{node:t});o=o.prev()}while(o);if(t.nodes)return e.warn("It looks like you didn't end your @import statement correctly. Child nodes are attached to it.",{node:t});const s=S(t.params).nodes;const a={type:"import",uri:"",fullUri:"",node:t,conditions:[...r],from:n};let i;let p;let u;for(let r=0;r<s.length;r++){const n=s[r];if(n.type!=="space"&&n.type!=="comment")if(n.type!=="string")if(n.type==="function"&&/^url$/i.test(n.value)){if(a.uri)return e.warn(`Multiple url's in '${t.toString()}'`,{node:t});if(!n.nodes?.[0]?.value)return e.warn(`Unable to find uri in '${t.toString()}'`,{node:t});a.uri=n.nodes[0].value;a.fullUri=C(n)}else{if(!a.uri)return e.warn(`Unable to find uri in '${t.toString()}'`,{node:t});if(n.type!=="word"&&n.type!=="function"||!/^layer$/i.test(n.value)){if(n.type!=="function"||!/^supports$/i.test(n.value)){p=C(s.slice(r));break}if(typeof u!=="undefined")return e.warn(`Multiple support conditions in '${t.toString()}'`,{node:t});u=C(n.nodes)}else{if(typeof i!=="undefined")return e.warn(`Multiple layers in '${t.toString()}'`,{node:t});if(typeof u!=="undefined")return e.warn(`layers must be defined before support conditions in '${t.toString()}'`,{node:t});i=n.nodes?C(n.nodes):""}}else{if(a.uri)return e.warn(`Multiple url's in '${t.toString()}'`,{node:t});if(!n.value)return e.warn(`Unable to find uri in '${t.toString()}'`,{node:t});a.uri=n.value;a.fullUri=C(n)}}if(!a.uri)return e.warn(`Unable to find uri in '${t.toString()}'`,{node:t});typeof p==="undefined"&&typeof i==="undefined"&&typeof u==="undefined"||a.conditions.push({layer:i,media:p,supports:u});return a}var E=I;var U=e;try{"default"in e&&(U=e.default)}catch(e){}var F=s;try{"default"in s&&(F=s.default)}catch(e){}var P={};const k=U;let A;P=function processContent(e,t,r,n,o){const{plugins:s}=n;const a=k.extname(r);const i=[];if(a===".sss"){if(!A)try{A=F}catch{}if(A)return runPostcss(o,t,r,s,[A])}e.opts.syntax?.parse&&i.push(e.opts.syntax.parse);e.opts.parser&&i.push(e.opts.parser);i.push(null);return runPostcss(o,t,r,s,i)};function runPostcss(e,t,r,n,o,s){s||(s=0);return e(n).process(t,{from:r,parser:o[s]}).catch((a=>{s++;if(s===o.length)throw a;return runPostcss(e,t,r,n,o,s)}))}var x=P;var D=e;try{"default"in e&&(D=e.default)}catch(e){}var L={};const M=D;const R=r;const j=E;const O=x;const B=a;const V=u;async function parseStyles$1(e,t,r,n,o,s,a){const i=j(e,t,o,s);for(const t of i)t.type==="import"&&isProcessableURL(t.uri)&&(r.filter&&!r.filter(t.uri)||await resolveImportId(e,t,r,n,a));let p;const u=[];const c=[];function handleCharset(e){if(p){if(e.node.params.toLowerCase()!==p.node.params.toLowerCase())throw e.node.error(`Incompatible @charset statements:\n  ${e.node.params} specified in ${e.node.source.input.file}\n  ${p.node.params} specified in ${p.node.source.input.file}`)}else p=e}i.forEach((e=>{e.type==="charset"?handleCharset(e):e.type==="import"?e.children?e.children.forEach(((t,r)=>{t.type==="import"?u.push(t):t.type==="charset"?handleCharset(t):c.push(t);r===0&&(t.parent=e)})):u.push(e):e.type==="nodes"&&c.push(e)}));return p?[p,...u.concat(c)]:u.concat(c)}async function resolveImportId(e,t,r,n,o){if(R.isValid(t.uri)){t.children=await loadImportContent(e,t,t.uri,r,n,o);return}if(R.isValid(t.from.slice(-1)))throw t.node.error(`Unable to import '${t.uri}' from a stylesheet that is embedded in a data url`);const s=t.node;let a;s.source?.input?.file&&(a=s.source.input.file);const i=a?M.dirname(s.source.input.file):r.root;const p=[await r.resolve(t.uri,i,r,s)].flat();const u=await Promise.all(p.map((e=>M.isAbsolute(e)?e:B(e,i,r,s))));u.forEach((t=>{e.messages.push({type:"dependency",plugin:"postcss-import",file:t,parent:a})}));const c=await Promise.all(u.map((s=>loadImportContent(e,t,s,r,n,o))));t.children=c.flat().filter((e=>!!e))}async function loadImportContent(e,t,r,n,o,s){const a=t.node;const{conditions:i,from:p}=t;const u=i.map((e=>V(e.layer,e.media,e.supports))).join(":");if(n.skipDuplicates){if(o.importedFiles[r]?.[u])return;o.importedFiles[r]||(o.importedFiles[r]={});o.importedFiles[r][u]=true}if(p.includes(r))return;const c=await n.load(r,n);if(c.trim()===""&&n.warnOnEmpty){e.warn(`${r} is empty`,{node:a});return}if(n.skipDuplicates&&o.hashFiles[c]?.[u])return;const l=await O(e,c,r,n,s);const d=l.root;e.messages=e.messages.concat(l.messages);if(n.skipDuplicates){const e=d.some((e=>e.type==="atrule"&&e.name==="import"));if(!e){o.hashFiles[c]||(o.hashFiles[c]={});o.hashFiles[c][u]=true}}return parseStyles$1(e,d,n,o,i,[...p,r],s)}function isProcessableURL(e){if(/^(?:[a-z]+:)?\/\//i.test(e))return false;try{const t=new URL(e,"https://example.com");if(t.search)return false}catch{}return true}L=parseStyles$1;var _=L;var z=e;try{"default"in e&&(z=e.default)}catch(e){}var q={};var G=i;const H=z;const J=y;const K=w;const N=$;const Q=n;const T=_;const W=a;function AtImport(e){e={root:G.cwd(),path:[],skipDuplicates:true,resolve:W,load:Q,plugins:[],addModulesDirectories:[],warnOnEmpty:true,...e};e.root=H.resolve(e.root);typeof e.path==="string"&&(e.path=[e.path]);Array.isArray(e.path)||(e.path=[]);e.path=e.path.map((t=>H.resolve(e.root,t)));return{postcssPlugin:"postcss-import",async Once(t,{result:r,atRule:n,postcss:o}){const s={importedFiles:{},hashFiles:{}};t.source?.input?.file&&(s.importedFiles[t.source.input.file]={});if(e.plugins&&!Array.isArray(e.plugins))throw new Error("plugins option must be an array");const a=await T(r,t,e,s,[],[],o);K(a);J(a,n);N(a,t)}}}AtImport.postcss=true;q=AtImport;var X=q;export{X as default};

